#include "items.hpp"
#include <yaml.h>
#include <stdio.h>
#include <stdexcept>

int items::load_items()
{
    FILE *fh = fopen("conf/items.yaml", "r");
    yaml_parser_t parser;
    yaml_event_t  event;   /* New variable */

    /* Initialize parser */
    if(!yaml_parser_initialize(&parser))
    {
        throw runtime_error("Failed to initialize parser.");
    }
    if(fh == NULL)
    {
        throw runtime_error("Failed to open file.");
    }

    /* Set input file */
    yaml_parser_set_input_file(&parser, fh);

    /* START new code */
    int mapping_level = 0;
    int sequence_level = 0;
    enum MappingLevels
    {
        TypeMapping = 1,
        Mapping = 2,
        PropertyMapping = 3
    };

    enum SequenceLevels
    {
        TypeOfItem = 1,
        Categories = 2
    };

    std::vector<ItemMap> items;
    ItemMap item;
    std::string key = "";

    ItemVal val;
    val.type = ItemValType::Empty;

    do
    {
        if (!yaml_parser_parse(&parser, &event))
        {
            printf("Parser error %d\n", parser.error);
            exit(EXIT_FAILURE);
        }

        switch(event.type)
        {
        case YAML_SEQUENCE_START_EVENT:
            if (sequence_level == Categories)
            {
                if (key == "category")
                {
                    val.type = ItemValType::StringVector;
                    val.strv = std::vector<std::string>();
                }
            }
            sequence_level++;
            break;

        case YAML_SEQUENCE_END_EVENT:
            if (sequence_level == Categories)
            {
                item[key] = val;
                val.type = ItemValType::Empty;
                val.strv = std::vector<std::string>();
                key = "";
            }
            sequence_level--;
            break;

        case YAML_MAPPING_START_EVENT:
            mapping_level++;
            break;

        case YAML_MAPPING_END_EVENT:
            mapping_level--;
            switch (mapping_level)
            {
            case Mapping:
                // Item::name (in this case in pre-postprocessing map)
                // is always a string (hopefully)
                items.push_back(item);
                item = std::map<std::string, ItemVal>();
                break;
            }
            break;

            /* Data */
        case YAML_SCALAR_EVENT:
            std::string strval(reinterpret_cast<char*>(event.data.scalar.value));
            if (sequence_level == Categories)
            {
                val.strv.push_back(strval);
            }
            else if (mapping_level == PropertyMapping)
            {
                if (key == "")
                {
                    key = strval;
                }
                else if (val.type == ItemValType::Empty)
                {
                    if (is_number(strval))
                    {
                        std::stringstream convert(strval);
                        convert >> val.i;
                        val.type = ItemValType::Integer;
                    }
                    else
                    {
                        val.str = strval;
                        val.type = ItemValType::String;
                    }
                }

                if (val.type != ItemValType::Empty && key != "")
                {
                    item[key] = val;
                    key = "";
                    val.type = ItemValType::Empty;
                }
            }
            else if (mapping_level == TypeMapping)
            {
                val.type = ItemValType::String;
                val.str = strval;
                item["broad_category"] = val;
                val.type = ItemValType::Empty;
            }
            else if (mapping_level == Mapping)
            {
                std::transform(strval.begin(), strval.end(), strval.begin(), [](char ch) {
                        return ch == ' ' ? '_' : toupper(ch);
                    });

                val.type = ItemValType::String;
                val.str = strval;
                item["name"] = val;
                val.type = ItemValType::Empty;
            }
            break;
        }
        if(event.type != YAML_STREAM_END_EVENT)
        {
            yaml_event_delete(&event);
        }
    }
    while(event.type != YAML_STREAM_END_EVENT);

    for (auto item : items)
    {
        for (auto map : item)
        {
            auto key = map.first;
            auto val = map.second;

            printf("%s: ", key.c_str());
            switch (val.type)
            {
            case ItemValType::String:
                printf("%s\n", val.str.c_str());
                break;
            case ItemValType::StringVector:
                printf("[%s]\n", join_string(val.strv).c_str());
                break;
            case ItemValType::Integer:
                printf("%d\n", val.i);
                break;
            default:
                printf("[%s]\n", join_string(val.strv).c_str());
                break;
            }
        }
    }

    yaml_event_delete(&event);
    /* END new code */

    /* Cleanup */
    yaml_parser_delete(&parser);
    fclose(fh);
    return 0;
}
